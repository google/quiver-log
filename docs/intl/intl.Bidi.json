{"name":"Bidi","qualifiedName":"intl/intl.Bidi","comment":"<p>This provides utility methods for working with bidirectional text. All\nof the methods are static, and are organized into a class primarily to\ngroup them together for documentation and discoverability.</p>","isAbstract":false,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{"LRE":{"name":"LRE","qualifiedName":"intl/intl.Bidi.LRE","comment":"<p>Unicode \"Left-To-Right Embedding\" (LRE) character.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"RLE":{"name":"RLE","qualifiedName":"intl/intl.Bidi.RLE","comment":"<p>Unicode \"Right-To-Left Embedding\" (RLE) character.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"PDF":{"name":"PDF","qualifiedName":"intl/intl.Bidi.PDF","comment":"<p>Unicode \"Pop Directional Formatting\" (PDF) character.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"LRM":{"name":"LRM","qualifiedName":"intl/intl.Bidi.LRM","comment":"<p>Unicode \"Left-To-Right Mark\" (LRM) character.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"RLM":{"name":"RLM","qualifiedName":"intl/intl.Bidi.RLM","comment":"<p>Unicode \"Right-To-Left Mark\" (RLM) character.</p>","final":false,"static":true,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"stripHtmlIfNeeded":{"name":"stripHtmlIfNeeded","qualifiedName":"intl/intl.Bidi.stripHtmlIfNeeded","comment":"<p>Returns the input <a>intl/intl.Bidi.stripHtmlIfNeeded.text</a> with spaces instead of HTML tags or HTML escapes,\nwhich is helpful for text directionality estimation.\nNote: This function should not be used in other contexts.\nIt does not deal well with many things: comments, script,\nelements, style elements, dir attribute,<code>&gt;</code> in quoted attribute values,\netc. But it does handle well enough the most common use cases.\nSince the worst that can happen as a result of these shortcomings is that\nthe wrong directionality will be estimated, we have not invested in\nimproving this.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"startsWithLtr":{"name":"startsWithLtr","qualifiedName":"intl/intl.Bidi.startsWithLtr","comment":"<p>Determines if the first character in <a>intl/intl.Bidi.startsWithLtr.text</a> with strong directionality is\nLTR. If <a>intl/intl.Bidi.startsWithLtr.isHtml</a> is true, the text is HTML or HTML-escaped.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"startsWithRtl":{"name":"startsWithRtl","qualifiedName":"intl/intl.Bidi.startsWithRtl","comment":"<p>Determines if the first character in <a>intl/intl.Bidi.startsWithRtl.text</a> with strong directionality is\nRTL. If <a>intl/intl.Bidi.startsWithRtl.isHtml</a> is true, the text is HTML or HTML-escaped.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"endsWithLtr":{"name":"endsWithLtr","qualifiedName":"intl/intl.Bidi.endsWithLtr","comment":"<p>Determines if the exit directionality (ie, the last strongly-directional\ncharacter in <a>intl/intl.Bidi.endsWithLtr.text</a> is LTR. If <a>intl/intl.Bidi.endsWithLtr.isHtml</a> is true, the text is HTML or\nHTML-escaped.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"endsWithRtl":{"name":"endsWithRtl","qualifiedName":"intl/intl.Bidi.endsWithRtl","comment":"<p>Determines if the exit directionality (ie, the last strongly-directional\ncharacter in <a>intl/intl.Bidi.endsWithRtl.text</a> is RTL. If <a>intl/intl.Bidi.endsWithRtl.isHtml</a> is true, the text is HTML or\nHTML-escaped.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"hasAnyLtr":{"name":"hasAnyLtr","qualifiedName":"intl/intl.Bidi.hasAnyLtr","comment":"<p>Determines if the given <a>intl/intl.Bidi.hasAnyLtr.text</a> has any LTR characters in it.\nIf <a>intl/intl.Bidi.hasAnyLtr.isHtml</a> is true, the text is HTML or HTML-escaped.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"hasAnyRtl":{"name":"hasAnyRtl","qualifiedName":"intl/intl.Bidi.hasAnyRtl","comment":"<p>Determines if the given <a>intl/intl.Bidi.hasAnyRtl.text</a> has any RTL characters in it.\nIf <a>intl/intl.Bidi.hasAnyRtl.isHtml</a> is true, the text is HTML or HTML-escaped.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"isRtlLanguage":{"name":"isRtlLanguage","qualifiedName":"intl/intl.Bidi.isRtlLanguage","comment":"<p>Check if a BCP 47 / III <a>intl/intl.Bidi.isRtlLanguage.languageString</a> indicates an RTL language.</p>\n<p>i.e. either:\n- a language code explicitly specifying one of the right-to-left scripts,\n  e.g. \"az-Arab\", or\n- a language code specifying one of the languages normally written in a\n  right-to-left script, e.g. \"fa\" (Farsi), except ones explicitly\n  specifying Latin or Cyrillic script (which are the usual LTR\n  alternatives).</p>\n<p>The list of right-to-left scripts appears in the 100-199 range in\nhttp://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and\nHebrew are by far the most widely used. We also recognize Thaana, N'Ko, and\nTifinagh, which also have significant modern usage. The rest (Syriac,\nSamaritan, Mandaic, etc.) seem to have extremely limited or no modern usage\nand are not recognized.\nThe languages usually written in a right-to-left script are taken as those\nwith Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in\nhttp://www.iana.org/assignments/language-subtag-registry,\nas well as Sindhi (sd) and Uyghur (ug).\nThe presence of other subtags of the language code, e.g. regions like EG\n(Egypt), is ignored.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"languageString":{"name":"languageString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"enforceRtlInHtml":{"name":"enforceRtlInHtml","qualifiedName":"intl/intl.Bidi.enforceRtlInHtml","comment":"<p>Enforce the <a>intl/intl.Bidi.enforceRtlInHtml.html</a> snippet in RTL directionality regardless of overall\ncontext. If the html piece was enclosed by a tag, the direction will be\napplied to existing tag, otherwise a span tag will be added as wrapper.\nFor this reason, if html snippet start with with tag, this tag must enclose\nthe whole piece. If the tag already has a direction specified, this new one\nwill override existing one in behavior (should work on Chrome, FF, and IE\nsince this was ported directly from the Closure version).</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"html":{"name":"html","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"enforceRtlInText":{"name":"enforceRtlInText","qualifiedName":"intl/intl.Bidi.enforceRtlInText","comment":"<p>Enforce RTL on both end of the given <a>intl/intl.Bidi.enforceRtlInText.text</a> using unicode BiDi formatting\ncharacters RLE and PDF.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"enforceLtrInHtml":{"name":"enforceLtrInHtml","qualifiedName":"intl/intl.Bidi.enforceLtrInHtml","comment":"<p>Enforce the <a>intl/intl.Bidi.enforceLtrInHtml.html</a> snippet in LTR directionality regardless of overall\ncontext. If the html piece was enclosed by a tag, the direction will be\napplied to existing tag, otherwise a span tag will be added as wrapper.\nFor this reason, if html snippet start with with tag, this tag must enclose\nthe whole piece. If the tag already has a direction specified, this new one\nwill override existing one in behavior (tested on FF and IE).</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"html":{"name":"html","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"enforceLtrInText":{"name":"enforceLtrInText","qualifiedName":"intl/intl.Bidi.enforceLtrInText","comment":"<p>Enforce LTR on both end of the given <a>intl/intl.Bidi.enforceLtrInText.text</a> using unicode BiDi formatting\ncharacters LRE and PDF.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"guardBracketInHtml":{"name":"guardBracketInHtml","qualifiedName":"intl/intl.Bidi.guardBracketInHtml","comment":"<p>Apply bracket guard to <a>intl/intl.Bidi.guardBracketInHtml.str</a> using html span tag. This is to address the\nproblem of messy bracket display that frequently happens in RTL layout.\nIf <a>intl/intl.Bidi.guardBracketInHtml.isRtlContext</a> is true, then we explicitly want to wrap in a span of RTL\ndirectionality, regardless of the estimated directionality.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"str":{"name":"str","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isRtlContext":{"name":"isRtlContext","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"guardBracketInText":{"name":"guardBracketInText","qualifiedName":"intl/intl.Bidi.guardBracketInText","comment":"<p>Apply bracket guard to <a>intl/intl.Bidi.guardBracketInText.str</a> using LRM and RLM. This is to address the\nproblem of messy bracket display that frequently happens in RTL layout.\nThis version works for both plain text and html, but in some cases is not\nas good as guardBracketInHtml.\nIf <a>intl/intl.Bidi.guardBracketInText.isRtlContext</a> is true, then we explicitly want to wrap in a span of RTL\ndirectionality, regardless of the estimated directionality.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"str":{"name":"str","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isRtlContext":{"name":"isRtlContext","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"estimateDirectionOfText":{"name":"estimateDirectionOfText","qualifiedName":"intl/intl.Bidi.estimateDirectionOfText","comment":"<p>Estimates the directionality of <a>intl/intl.Bidi.estimateDirectionOfText.text</a> using the best known\ngeneral-purpose method (using relative word counts). A\nTextDirection.UNKNOWN return value indicates completely neutral input.\n<a>intl/intl.Bidi.estimateDirectionOfText.isHtml</a> is true if <a>intl/intl.Bidi.estimateDirectionOfText.text</a> HTML or HTML-escaped.</p>\n<p>If the number of RTL words is above a certain percentage of the total\nnumber of strongly directional words, returns RTL.\nOtherwise, if any words are strongly or weakly LTR, returns LTR.\nOtherwise, returns UNKNOWN, which is used to mean <code>neutral</code>.\nNumbers and URLs are counted as weakly LTR.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"intl/intl.TextDirection","inner":[]}],"parameters":{"text":{"name":"text","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"normalizeHebrewQuote":{"name":"normalizeHebrewQuote","qualifiedName":"intl/intl.Bidi.normalizeHebrewQuote","comment":"<p>Replace the double and single quote directly after a Hebrew character in\n<a>intl/intl.Bidi.normalizeHebrewQuote.str</a> with GERESH and GERSHAYIM. This is most likely the user's intention.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"str":{"name":"str","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"detectRtlDirectionality":{"name":"detectRtlDirectionality","qualifiedName":"intl/intl.Bidi.detectRtlDirectionality","comment":"<p>Check the estimated directionality of <a>intl/intl.Bidi.detectRtlDirectionality.str</a>, return true if the piece of\ntext should be laid out in RTL direction. If <a>intl/intl.Bidi.detectRtlDirectionality.isHtml</a> is true, the string\nis HTML or HTML-escaped.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"str":{"name":"str","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"isHtml":{"name":"isHtml","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"intl/intl.Bidi.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>intl/intl.Bidi.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"intl/intl.Bidi.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"intl/intl.Bidi.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>intl/intl.Bidi.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>intl/intl.Bidi.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"intl/intl.Bidi.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"intl/intl.Bidi.noSuchMethod","comment":"<p><a>intl/intl.Bidi.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>intl/intl.Bidi.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>intl/intl.Bidi.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>intl/intl.Bidi.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}