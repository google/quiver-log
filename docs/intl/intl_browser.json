{"name":"intl_browser","qualifiedName":"intl/intl_browser","comment":"<p>This provides facilities for Internationalization that are only available\nwhen running in the web browser. You should import only one of this or\nintl_standalone.dart. Right now the only thing provided here is the\nability to find the default locale from the browser.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"findSystemLocale":{"name":"findSystemLocale","qualifiedName":"intl/intl_browser.findSystemLocale","comment":"<p>Find the system locale, accessed as window.navigator.language, and\nset it as the default for internationalization operations in the\n<a>intl/intl.Intl.systemLocale</a> variable.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]}}},"classes":{"class":[],"typedef":{},"error":[]},"packageName":"intl","packageIntro":"<h1>Intl</h1>\n<p>This package provides internationalization and localization facilities,\nincluding message translation, plurals and genders, date/number formatting\nand parsing, and bidirectional text.</p>\n<h2>General</h2>\n<p>The most important library is <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl.html\">intl</a>. It defines the <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html\">Intl</a>\nclass, with the default locale and methods for accessing most of the\ninternationalization mechanisms. This library also defines the\n<a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/DateFormat.html\">DateFormat</a>, <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/NumberFormat.html\">NumberFormat</a>, and\n<a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/BidiFormatter.html\">BidiFormatter</a> classes.</p>\n<h2>Current locale</h2>\n<p>The package has a single current locale, called <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html#defaultLocale\">defaultLocale</a>.\nOperations will use that locale unless told to do otherwise.</p>\n<p>To set the global locale, you can explicitly set it, e.g.</p>\n<pre><code>  Intl.defaultLocale = 'pt_BR';\n</code></pre>\n<p>or get it from the browser by</p>\n<pre><code>  import \"package:intl/intl_browser.dart\";\n  ...\n  findSystemLocale().then(runTheRestOfMyProgram);\n</code></pre>\n<p>To temporarily override the current locale, pass the operation\nto <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html#withLocale\">withLocale</a>.</p>\n<pre><code>  Intl.withLocale('fr', () =&gt; print(myLocalizedMessage());\n</code></pre>\n<p>To override it for a very specific operation you can create a format object in\na specific locale, or pass in the locale as a parameter to methods.</p>\n<pre><code>  var format = new DateFormat.yMd(\"ar\");\n  var dateString = format.format(new DateTime.now());\n  print(myMessage(dateString, locale: 'ar');\n</code></pre>\n<h2>Initialization</h2>\n<p>All the different types of locale data require an async initialization step\nto make\nsure the data is available. This reduces the size of the application by only\nloading the\ndata that is actually required. However, deferred loading does not yet work for\nmultiple\nlibraries, so currently all the code will be included anyay, increasing the code\nsize in the short term.</p>\n<p>Each different area of internationalization (messages, dates, numbers) requires\na separate initialization process. That way, if the application only needs to\nformat dates, it doesn't need to take the time or space to load up messages,\nnumbers, or other things it may not need.</p>\n<p>With messages, there is also a need to import a file that won't exist until\nthe code generation step has been run. This can be awkward, but can be worked\naround by creating a stub <code>messages_all.dart</code> file, running an empty translation\nstep, or commenting out the import until translations are available.\nSee \"Extracting and Using Translated Messages\"</p>\n<h2>Messages</h2>\n<p>Messages to be localized are written as functions that return the result of\nan <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html#message\">Intl.message</a> call.</p>\n<pre><code>  String continueMessage() =&gt; Intl.message(\n      \"Hit any key to continue\",\n      name: \"continueMessage\",\n      args: [],\n      desc: \"Explains that we will not proceed further until \"\n          \"the user presses a key\");\n  print(continueMessage());\n</code></pre>\n<p>This provides, in addition to the basic message string, a name, a\ndescription for translators, the arguments used in the message, and\nexamples. The <code>name</code> and <code>args</code> parameters are required, and must\nmatch the name and arguments list of the function.  In the future we\nhope to have these provided automatically.</p>\n<p>This can be run in the program before any translation has been done,\nand will just return the message string. It can also be extracted to a\nfile and then be made to return a translated version without modifying\nthe original program. See \"Extracting Messages\" below for more\ndetails.</p>\n<p>The purpose of wrapping the message in a function is to allow it to\nhave parameters which can be used in the result. The message string is\nallowed to use a restricted form of Dart string interpolation, where\nonly the function's parameters can be used, and only in simple\nexpressions. Local variables cannot be used, and neither can\nexpressions with curly braces. Only the message string can have\ninterpolation. The name, desc, args, and examples must be literals and\nnot contain interpolations. Only the args parameter can refer to\nvariables, and it should list exactly the function parameters. If you\nare passing numbers or dates and you want them formatted, you must do\nthe formatting outside the function and pass the formatted string into\nthe message.</p>\n<pre><code>  greetingMessage(name) =&gt; Intl.message(\n      \"Hello $name!\",\n      name: \"greetingMessage\",\n      args: [name],\n      desc: \"Greet the user as they first open the application\",\n      examples: {'name': \"Emily\"});\n  print(greetingMessage('Dan'));\n</code></pre>\n<p>There is one special class of complex expressions allowed in the\nmessage string, for plurals and genders.</p>\n<pre><code>  remainingEmailsMessage(int howMany, String userName) =&gt; \n    Intl.message(\n      \"${Intl.plural(howMany,\n          zero: 'There are no emails left for $userName.',\n          one: 'There is one email left for $userName.',\n          other: 'There are $howMany emails left for $userName.')}\",\n    name: \"remainingEmailsMessage\",\n    args: [howMany, userName],\n    desc: \"How many emails remain after archiving.\",\n    examples: {'number': 42, 'userName': 'Fred'});\n\n  print(remainingEmailsMessage(1, \"Fred\"));\n</code></pre>\n<p>However, since the typical usage for a plural or gender is for it to\nbe at the top-level, we can also omit the <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html#message\">Intl.message</a> call and\nprovide its parameters to the <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html#plural\">Intl.plural</a> call instead.</p>\n<pre><code>  remainingEmailsMessage(int howMany, String userName) =&gt; \n    Intl.plural(\n      howMany,\n      zero: 'There are no emails left for $userName.',\n      one: 'There is one email left for $userName.',\n      other: 'There are $howMany emails left for $userName.'),\n      name: \"remainingEmailsMessage\",\n      args: [howMany, userName],\n      desc: \"How many emails remain after archiving.\",\n      examples: {'number': 42, 'userName': 'Fred'});\n</code></pre>\n<p>Similarly, there is an <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html#gender\">Intl.gender</a> message, and plurals\nand genders can be nested.</p>\n<pre><code>  notOnlineMessage(String userName, String userGender) =&gt; \n    Intl.gender(\n      userGender,\n      male: '$userName is unavailable because he is not online.',\n      female: '$userName is unavailable because she is not online.',\n      other: '$userName is unavailable because they are not online'),\n      name: \"notOnlineMessage\",\n      args: [userName, userGender],\n      desc: \"The user is not available to hangout.\",\n      examples: {{'userGender': 'male', 'userName': 'Fred'},\n          {'userGender': 'female', 'userName' : 'Alice'}});\n</code></pre>\n<h2>Extracting And Using Translated Messages</h2>\n<p>When your program contains messages that need translation, these must\nbe extracted from the program source, sent to human translators, and the\nresults need to be incorporated. This is still work in progress, and\nthe extraction is done to a custom JSON format that is not supported\nby translation tools. We intend to support one or more actual\ntranslation file formats.</p>\n<p>To extract messages, run the <code>pkg/intl/test/extract_to_json.dart</code> program.</p>\n<pre><code>  dart extract_to_json.dart --output-dir=target/directory\n      my_program.dart more_of_my_program.dart\n</code></pre>\n<p>This will produce a file <code>intl_messages.json</code> with the messages from\nall of these programs. This is in a simple JSON format with a map from\nmessage names to message strings.</p>\n<p>The reverse step expects to receive a series of files, one per\nlocale. These consist of a map with the entry for \"_locale\" indicating\nthe locale, and with the function name mapped to the translated\nstring. However, plurals and genders are currently represented in an\nopaque form, by serializing the internal objects that represent\nthem. You can see the generation of this code in the\n<code>make_hardcoded_translation.dart</code> test file.</p>\n<p>If you manage to create such a set of input files, then you can run</p>\n<pre><code>  dart generate_from_json.dart --generated_file_prefix=&lt;prefix&gt; \n      &lt;my dart files&gt; &lt;translated json files&gt;\n</code></pre>\n<p>This will generate Dart libraries, one per locale, which contain the\ntranslated versions. Your Dart libraries can import the primary file,\nnamed <code>&lt;prefix&gt;messages_all.dart</code>, and then call the initialization\nfor a specific locale. Once that's done, any\n<a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/Intl.html#message\">Intl.message</a> calls made in the context of that locale\nwill automatically print the translated version instead of the\noriginal.</p>\n<pre><code>  import \"my_prefix_messages_all.dart\";\n  ...\n  initializeMessages(\"dk\").then(printSomeMessages);\n</code></pre>\n<p>Once the future returned from the initialization call returns, the\nmessage data is available.</p>\n<h2>Number Formatting and Parsing</h2>\n<p>To format a number, create a NumberFormat instance.</p>\n<pre><code>  var f = new NumberFormat(\"###.0#\", \"en_US\");\n  print(f.format(12.345));\n    ==&gt; 12.34\n</code></pre>\n<p>The locale parameter is optional. If omitted, then it will use the\ncurrent locale. The format string is as described in\n<a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/NumberFormat.html\">NumberFormat</a></p>\n<p>It's also possible to access the number symbol data for the current\nlocale, which provides information as to the various separator\ncharacters, patterns, and other information used for formatting, as</p>\n<pre><code>  f.symbols\n</code></pre>\n<p>Current known limitations are that the currency format will only print\nthe name of the currency, and does not support currency symbols, and\nthat the scientific format does not really agree with scientific\nnotation. Number parsing is not yet implemented.</p>\n<p>Note that before doing any number formatting for a particular locale\nyou must load the appropriate data by calling</p>\n<pre><code>  import 'package:intl/number_symbols_data_local.dart';\n  ...\n  initializeNumberFormatting(localeName, null).then(formatNumbers);\n</code></pre>\n<p>Once the future returned from the initialization call returns, the\nformatting data is available. Note that right now this includes all\nthe data for a locales. We expect to make this use deferred loading to\nreduce code size.</p>\n<h2>Date Formatting and Parsing</h2>\n<p>To format a <a href=\"https://api.dartlang.org/docs/channels/stable/latest/dart_core/DateTime.html\">DateTime</a>, create a <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/DateFormat.html\">DateFormat</a>\ninstance. These can be created using a set of commonly used skeletons\ntaken from ICU/CLDR or using an explicit pattern. For details on the\nsupported skeletons and patterns see <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/DateFormat.html\">DateFormat</a>.</p>\n<pre><code>  new DateFormat.yMMMMEEEEd().format(aDateTime);\n    ==&gt; 'Wednesday, January 10, 2012'\n  new DateFormat(\"EEEEE\", \"en_US\").format(aDateTime);\n    ==&gt; 'Wednesday'\n  new DateFormat(\"EEEEE\", \"ln\").format(aDateTime);\n    ==&gt; 'mokɔlɔ mwa mísáto'\n</code></pre>\n<p>You can also parse dates using the same skeletons or patterns.</p>\n<pre><code>    new DateFormat.yMd(\"en_US\").parse(\"1/10/2012\");\n    new DateFormat(\"Hms\", \"en_US\").parse('14:23:01');\n</code></pre>\n<p>Skeletons can be combined, the main use being to print a full date and\ntime, e.g.</p>\n<pre><code>    new DateFormat.yMEd().add_jms().format(new DateTime.now());\n      ==&gt; 'Thu, 5/23/2013 10:21:47 AM'\n</code></pre>\n<p>Known limitations: Time zones are not yet supported. Dart\n<a href=\"https://api.dartlang.org/docs/channels/stable/latest/dart_core/DateTime.html\">DateTime</a> objects don't have a time zone, so are either\nlocal or UTC. Formatting and parsing Durations is not yet implemented.</p>\n<p>Note that before doing any DateTime formatting for a particular\nlocale, you must load the appropriate data by calling.</p>\n<pre><code>    import 'package:intl/date_symbol_data_local.dart';\n    ...\n    initializeDateFormatting(\"de_DE\", null).then(formatDates);\n</code></pre>\n<p>Once the future returned from the initialization call returns, the\nformatting data is available.</p>\n<p>There are other mechanisms for loading the date formatting data\nimplemented, but we expect to deprecate those in favor of having the\ndata in a library as in the above, and using deferred loading to only\nload the portions that are needed. For the time being, this will\ninclude all of the data, which will increase code size.</p>\n<h2>Bidirectional Text</h2>\n<p>The class <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/BidiFormatter.html\">BidiFormatter</a> provides utilities for\nworking with Bidirectional text. We can wrap the string with unicode\ndirectional indicator characters or with an HTML span to indicate\ndirection. The direction can be specified with the\n<a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/BidiFormatter.html#RTL\">RTL</a> and <a href=\"https://api.dartlang.org/docs/channels/stable/latest/intl/BidiFormatter.html#LTR\">LTR</a> constructors, or\ndetected from the text.</p>\n<pre><code>    new BidiFormatter.RTL().wrapWithUnicode('xyz');\n    new BidiFormatter.RTL().wrapWithSpan('xyz');\n</code></pre>"}